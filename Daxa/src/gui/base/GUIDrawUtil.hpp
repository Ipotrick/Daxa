#pragma once

#include "../../rendering/UISprite.hpp"

#include "GUIDrawContext.hpp"

namespace daxa {
	namespace gui {

		/**
		 * \param size must be allready scaled by the given context.
		 * \return place generated by given parameters, scaled by the context.scale.
		 */
		static constexpr Vec2 getPlace(const Vec2 scaledSize, const Placing& placeing, const DrawContext& context) 	{
			Vec2 place{ 0,0 };
			switch (placeing.xmode) {
			case Placing::XMode::AbsoluteLeft:
				place.x = context.left() + scaledSize.x * 0.5f + placeing.x * context.scale; break;
			case Placing::XMode::AbsoluteRight:
				place.x = context.right() - scaledSize.x * 0.5f - placeing.x * context.scale; break;
			case Placing::XMode::RelativeLeft:
				place.x = context.left() + scaledSize.x * 0.5f + placeing.x * (context.size().x - scaledSize.x); break;
			case Placing::XMode::RelativeRight:
				place.x = context.right() - scaledSize.x * 0.5f - placeing.x * (context.size().y - scaledSize.x); break;
			default: break;
			};
			switch (placeing.ymode) {
			case Placing::YMode::AbsoluteTop:
				place.y = context.top() - scaledSize.y * 0.5f - placeing.y * context.scale; break;
			case Placing::YMode::AbsoluteBottom:
				place.y = context.bottom() + scaledSize.y * 0.5f + placeing.y * context.scale; break;
			case Placing::YMode::RelativeTop:
				place.y = context.top() - scaledSize.y * 0.5f - placeing.y * (context.size().y - scaledSize.y); break;
			case Placing::YMode::RelativeBottom:
				place.y = context.bottom() + scaledSize.y * 0.5f + placeing.y * (context.size().y - scaledSize.y); break;
			default: break;
			};
			return place;
		}

		/**
		 * \param size must be allready scaled by the given context.
		 * \param context contains the alignment and the bounds, wich are used to determine the placeing.
		 * \return place generated by given parameters, scaled by the context.scale.
		 */
		static constexpr float getXPlace(const Vec2 scaledSize, const DrawContext& context) 	{
			float place{ 0.0f };
			switch (context.xalign) {
			case XAlign::Left:
				place = context.left() + scaledSize.x * 0.5f; break;
			case XAlign::Right:
				place = context.right() - scaledSize.x * 0.5f; break;
			case XAlign::Center:
				place = context.centerpos().x; break;
			default:
				assert(false);	// all other alignments are "faked" and must be replaced by the alignments above
			};
			return place;
		}

		/**
		 * \param size must be allready scaled by the given context.
		 * \param context contains the alignment and the bounds, wich are used to determine the placeing.
		 * \return place generated by given parameters, scaled by the context.scale.
		 */
		static constexpr float getYPlace(const Vec2 scaledSize, const DrawContext& context) 	{
			float place{ 0.0f };
			switch (context.yalign) {
			case YAlign::Top:
				place = context.top() - scaledSize.y * 0.5f; break;
			case YAlign::Bottom:
				place = context.bottom() + scaledSize.y * 0.5f; break;
			case YAlign::Center:
				place = context.centerpos().y; break;
			default:
				assert(false);	// all other alignments are "faked" and must be replaced by the alignments above
			};
			return place;
		}
		/**
		 * \param context contains the alignmentand the bounds, wich are used to determine the placeing.
		 * \return place generated by given parameters, scaled by the context.scale.
		 */
		static constexpr Vec2 getPlace(const Vec2 scaledSize, const DrawContext& context) 	{
			return Vec2{ getXPlace(scaledSize, context), getYPlace(scaledSize, context) };
		}

		/**
		 * \return scaled place relative to the context and sizeing, scaled by context.scale.
		 */
		static constexpr Vec2 getPlace(const Sizing& sizeing, const Placing& placeing, const DrawContext& context) 	{
			return getPlace(getSize(sizeing, context), placeing, context);
		}

		/**
		 * \return the position of the top left corner of the area generated by and object with the given placeing and sizeing in the given context.
		 */
		static constexpr Vec2 getTLCorner(const Sizing& sizeing, const Placing& placeing, const DrawContext& context) 	{
			const Vec2 size = getSize(sizeing, context);
			const Vec2 place = getPlace(size, placeing, context);
			return Vec2{ place.x - size.x * 0.5f, place.y + size.y * 0.5f };
		}

		/**
		 * \return the position of the bottom right corner of the area generated by and object with the given placeing and sizeing in the given context.
		 */
		static constexpr Vec2 getBRCorner(const Sizing& sizeing, const Placing& placeing, const DrawContext& context) 	{
			const Vec2 size = getSize(sizeing, context);
			const Vec2 place = getPlace(size, placeing, context);
			return Vec2{ place.x + size.x * 0.5f, place.y - size.y * 0.5f };
		}

		/**
		 * \return 4 rectangles representing the corners of the bounds of the given context.
		 */
		inline static std::array<UISprite, 4> debugContextCorners(DrawContext const& context) 	{
			return {
				UISprite{
					.color = Vec4{1,0.5,1,1},
					.position = {context.topleft, context.renderDepth},
					.scale = {2,2},
					.drawMode = context.renderSpace
				},
				UISprite{
					.color = Vec4{1,0.5,1,1},
					.position = {context.bottomright, context.renderDepth},
					.scale = {2,2},
					.drawMode = context.renderSpace
				},
				UISprite{
					.color = Vec4{1,0.5,1,1},
					.position = Vec3{context.topleft.x, context.bottomright.y, context.renderDepth},
					.scale = {2,2},
					.drawMode = context.renderSpace
				},
				UISprite{
					.color = Vec4{1,0.5,1,1},
					.position = Vec3{context.bottomright.x, context.topleft.y, context.renderDepth},
					.scale = {2,2},
					.drawMode = context.renderSpace
				}
			};
		}

		inline static std::pair<Vec2, Vec2> getWindowSpaceMinMax(Vec2 place, Vec2 scaledSize, RenderSpace2d originSpace, const RenderCoordSys& coordSys) 	{
			const Vec2 min = coordSys.convertCoordSys(place - scaledSize * 0.5f, originSpace, RenderSpace2d::Window);
			const Vec2 max = coordSys.convertCoordSys(place + scaledSize * 0.5f, originSpace, RenderSpace2d::Window);
			return { min,max };
		}

		inline static std::pair<Vec2, Vec2> getScreenTextureMinMax(Vec2 place, Vec2 scaledSize, RenderSpace2d originSpace, const RenderCoordSys& coordSys) 	{
			const Vec2 min = (coordSys.convertCoordSys(place - scaledSize * 0.5f, originSpace, RenderSpace2d::Window) + Vec2{ 1.0f,1.0f }) * 0.5f;
			const Vec2 max = (coordSys.convertCoordSys(place + scaledSize * 0.5f, originSpace, RenderSpace2d::Window) + Vec2{ 1.0f,1.0f }) * 0.5f;
			return { min,max };
		}
	}
}